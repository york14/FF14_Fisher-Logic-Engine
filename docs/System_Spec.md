# 漁師論理エンジン (FLE) システム仕様書

**Version**: 3.0.0
**Last Updated**: 2026/01/13
**Target Logic**: FLE v2.5.4 / Data Converter v2.8

---

## 目次
1.  **ドメイン知識 (Domain Knowledge)**
    * 1.1 釣りの基本メカニクス
    * 1.2 抽選の仕組み (Weight System)
    * 1.3 アクションと状態変化
    * 1.4 隠し魚の出現論理
2.  **システム要件 (System Requirements)**
    * 2.1 機能構成
    * 2.2 UI仕様と状態管理
    * 2.3 エラーハンドリング
3.  **ロジック仕様 (Logic Specification)**
    * 3.1 定数定義 (GDS)
    * 3.2 シナリオIDと状態定義
    * 3.3 確率・重み計算ロジック
    * 3.4 時間計算ロジック
4.  **データ構造 (Data Structure)**
    * 4.1 マスターデータ構造 (JSON)
    * 4.2 データ変換ロジック (CSV to JSON)

---

## 1. ドメイン知識 (Domain Knowledge)

本システムがシミュレートする対象である「FF14の釣り」に関する基本概念とルールを定義する。

### 1.1 釣りの基本メカニクス
釣りは「キャスト（開始）」から「フッキング（釣り上げ）または竿上げ（中断）」までを1つの**サイクル**として扱う。

1.  **キャスト (Cast)**: 釣りを開始する動作。
2.  **待機 (Wait)**: 魚がかかる（バイトする）までの時間。
3.  **アタリ (Bite)**: 魚がかかった合図。振動（演出）としてプレイヤーに伝わる。
4.  **フッキング (Hooking)**: アタリに合わせて釣り上げる動作。成功すると魚を獲得し、サイクルが終了する。
5.  **竿上げ (Rod Lift)**: 魚がかかる前、またはかかった後に、釣らずに中断する動作。魚は獲得できず、サイクルが終了する。

### 1.2 抽選の仕組み (Weight System)
魚の抽選は、各魚種に設定された**「重み (Weight)」**に基づく確率的抽選によって行われる。

* **基礎重み**: 釣り場・天気・餌の条件ごとに定義された初期値。
* **重み補正**: プレイヤーのアクション（ルアー使用など）によって、特定の魚種の重みが増減する。
* **抽選確率**:
    $$P(魚種A) = \frac{\text{魚種Aの現在重み}}{\text{全候補の現在重みの総和}}$$

### 1.3 アクションと状態変化
プレイヤーは以下のスキルを使用して抽選確率や時間を操作できる。

| アクション名 | ゲーム内名称 | 効果概要 |
| :--- | :--- | :--- |
| **撒き餌** | Chum | 魚がかかるまでの待機時間を短縮する。 |
| **トレード** | Surface Slap | 特定の魚種を次回の抽選候補から除外する（重みを0にする）。 |
| **ルアー** | Ambitious/Modest | 「大型」または「小型」の魚の重みを増加させ、「隠し魚」の発見を試みる。 |

### 1.4 隠し魚の出現論理
一部の魚種は**「隠し魚 (Hidden Fish)」**として設定されており、通常状態では重みが0（出現しない）である。以下の手順でのみ出現する。

1.  **発見 (Discovery)**: ルアーアクションを使用した際、一定確率で「魚の気配」を発見する。
2.  **型確定 (Identification)**: 発見後、さらにルアーを使用することで「魚の型（大型/小型）」が確定する場合がある。
3.  **出現**: 発見状態でのみ、隠し魚は固有のヒット率を持ち、抽選テーブルに乗る。

---

## 2. システム要件 (System Requirements)

### 2.1 機能構成

#### A. 手動設定モード (Manual Mode)
特定の条件とスキル回数を指定し、その単一シナリオにおける詳細な確率と時間を計算するモード。

* **入力**: 釣り場、天気、餌、ターゲット、ルアー種類・回数、各ステップの結果(発見/型確/なし)。
* **出力**: ターゲットヒット率、サイクル時間、期待待機時間、全魚種の内訳テーブル。
* **実装関数**: `runManualMode(config)`

#### B. 戦略評価モード (Strategy Mode)
複数のシナリオ（成功・失敗パターン）を内包した「戦略プリセット」を選択し、戦略全体の平均的なパフォーマンスを評価・比較するモード。

* **入力**: 戦略セットA/Bそれぞれのプリセット（例：「L2固定」「発見延長優先」）、ルアー設定。
* **出力**: セットA/Bの期待値比較カード、シナリオ発生確率Top3、ヒット率Top3。
* **実装関数**: `runStrategyMode(config)`

### 2.2 UI仕様と状態管理

#### レイアウト
* **3ペイン構成**:
    * 左パネル: 設定（入力）
    * 中央パネル: 結果（出力）
    * 右パネル: 詳細デバッグ（折りたたみ可能）
* **リサイザー**: パネル間の境界線をドラッグして幅を調整可能。
    * 実装: `initResizers()`

#### 状態管理フロー
1.  **初期状態**: `OFFLINE`。JSON読み込み待ち。全コントロール無効化。
2.  **ロード後**: `ONLINE`。`masterDB` にデータ格納。`probabilityMap` 生成。コントロール有効化。
3.  **再計算トリガー**: 各種プルダウン/チェックボックスの `change` イベントで `updateSimulation()` を呼び出す。

### 2.3 エラーハンドリング

#### データ未定義エラー
ユーザーが選択した「釣り場」に対応する詳細データ（魚リスト等）がマスタに存在しない場合。

* **検知**: `masterDB.spots[spot].fish_list.length === 0`
* **挙動**:
    * 計算処理を中断 (`return`)。
    * 中央パネルに赤枠で「⚠️ データ未定義」を表示。
    * `updateSpotDependents()` 内で制御。

#### 不正な設定エラー
* **例**: ルアー設定で「発見」を2回以上選択した場合。
* **挙動**: 赤字で「発見は1度までです」と表示し、計算を中断。

---

## 3. ロジック仕様 (Logic Specification)

本システムの核心となる計算アルゴリズムおよび定数を定義する。

### 3.1 定数定義 (GDS)
時間の計算および重み補正に使用する標準定数（**GDS**: Game Duration Standards）。

| 定数名 | 値 | 単位 | 説明 |
| :--- | :--- | :--- | :--- |
| `D_CAST` | **1.0** | sec | キャスト（投げ入れ）にかかる動作時間。 |
| `D_LURE` | **2.5** | sec | ルアーアクション1回あたりの動作時間。 |
| `D_BLK` | **2.5** | sec | ルアー使用後の硬直時間（魚がかからない空白時間）。 |
| `D_CHUM` | **1.0** | sec | 撒き餌を使用する際のアニメーション時間。 |
| `D_REST` | **2.0** | sec | 竿上げ（中断/リリース）にかかる動作時間。 |
| `C_CHUM` | **0.6** | - | 撒き餌使用時のバイト時間短縮係数（乗算）。 |
| `M_N1` | **1.5** | - | ルアー1回使用時の、適合する型の魚への重み倍率。 |
| `M_N2` | **2.0** | - | ルアー2回使用時の、適合する型の魚への重み倍率。 |
| `M_N3` | **6.0** | - | ルアー3回使用時の、適合する型の魚への重み倍率。 |

**実装コード (main.js)**:
```javascript
const GDS = {
    D_CAST: 1.0, D_LURE: 2.5, D_BLK: 2.5, D_CHUM: 1.0, D_REST: 2.0,
    C_CHUM: 0.6, M_N1: 1.5, M_N2: 2.0, M_N3: 6.0
};
```

### 3.2 シナリオIDと状態定義
ルアーの使用結果（シナリオ）は、以下のID形式で一意に管理する。

**フォーマット**: `n{回数}_d{発見ステップ}_g{型確定ステップ}`

* **n (Number)**: ルアーを使用した総回数 (0, 1, 2, 3)。
* **d (Discovery)**: 何回目のルアーで「発見」したか (0=なし, 1, 2, 3)。発見は最大1回まで。
* **g (Guarantee)**: 何回目のルアーで「型確定」したか (0=なし, 複数可 例:12, 23)。

**生成ロジック (`constructScenarioId` / `parseScenarioId`)**:
```javascript
// ID生成のイメージ
function constructScenarioId(count, steps) {
    let disc = 0;
    let guars = [];
    steps.forEach((action, i) => {
        if (action === 'disc' && disc === 0) disc = i + 1;
        if (action === 'guar') guars.push(i + 1);
    });
    const gStr = guars.length > 0 ? guars.join('') : '0';
    return `n${count}_d${disc}_g${gStr}`; // 例: n2_d1_g2
}
```

### 3.3 確率・重み計算ロジック

#### 3.3.1 シナリオ発生確率
各シナリオが発生する確率は、マスタデータ（`probabilities`）に定義された「各ステップごとの確率」を乗算して求める。

**計算フロー (`calculateScenarioStats` 内)**:
```javascript
let scenarioProb = 1.0;
// 各ステップ i (1～n) についてループ
for (let i = 1; i <= n; i++) {
    let stepProb = 0;
    if (!found) { // 未発見状態
        // disc_rates[i-1], guar_rates_nodisc[i-1] を使用
        if (action === 'disc') stepProb = pDisc;
        else if (action === 'guar') stepProb = (1.0 - pDisc) * pGuar;
        else stepProb = (1.0 - pDisc) * (1.0 - pGuar);
    } else { // 発見済み状態
        // guar_rates_after_disc を使用
        stepProb = (action === 'guar') ? pGuarAfter : (1.0 - pGuarAfter);
    }
    scenarioProb *= stepProb;
}
```

#### 3.3.2 魚種ごとのヒット率 ($P_{Hit}$)
シナリオ確定後の各魚種のヒット率は以下の手順で算出する。

1.  **隠し魚の判定**:
    * シナリオIDに対応する固定ヒット率をマスタから取得する ($P_{Hidden}$)。
    * 未発見シナリオ、またはデータがない場合は 0% とする。

2.  **通常魚の重み計算**:
    * 各魚種 $i$ について、基礎重み $W_{base}$ に補正倍率 $M$ を掛ける。
    * $M$ の決定ルール:
        * トレード対象魚: $M = 0$
        * ルアー使用かつ型が一致: $M = M_{N\text{x}}$ (回数に応じた倍率)
        * ルアー使用かつ型が不一致:
            * 直近で型確定している場合: $M = 0$
            * それ以外: $M = 1.0$
    * 最終重み $W_{final, i} = W_{base, i} \times M$

**実装コード (`calculateScenarioStats` 内)**:
```javascript
baseWeights.forEach(w => {
    let m = 1.0;
    if (w.fish === tradeFish) { m = 0; }
    else if (lureActive) {
        if (typeMatch) m = modN; // M_N1, M_N2, M_N3
        else m = lastGuar ? 0 : 1.0;
    }
    weightDetails.push({ final: w.weight * m, /* ... */ });
});
```

3.  **確率分配**:
    * 通常魚の合計重み $W_{total} = \sum W_{final}$
    * 通常魚 $i$ のヒット率:
        $$P_i = \frac{W_{final, i}}{W_{total}} \times (1.0 - P_{Hidden})$$

### 3.4 時間計算ロジック

1サイクルにかかる時間は、プレイスタイル設定（特に「未発見即竿上げ」）によって計算式が異なる。

#### A. 通常サイクル（釣り上げ/リリース）
魚がかかるのを待ち、ヒット後に釣り上げる（またはリリースする）場合の所要時間。

$$T_{Cycle} = T_{Pre} + D_{Cast} + T_{Wait} + T_{Hook}$$

* **$T_{Pre}$**: 撒き餌使用時は `D_CHUM`、未使用時は 0。
* **$T_{Wait}$**: 以下の2つの値の**大きい方**を採用する。
    1.  **バイト時間**: 魚固有の基礎待機時間 $\times$ (`C_CHUM` or 1.0)。
    2.  **ルアー拘束時間**: $D_{Cast} + (n \times D_{Lure}) + D_{BLK}$
        * ※ルアー動作中は魚がかからないため、ルアー回数が多いほど最低待機時間は長くなる。
* **$T_{Hook}$**:
    * ターゲット魚またはCatchAll対象の場合: 魚固有の `hook_time`。
    * 外道（リリース）の場合: `D_REST`。

**実装コード**:
```javascript
const biteTime = isChum ? (baseBite * GDS.C_CHUM) : baseBite;
const lureTime = tCast + (n * tLureAction) + tLureBlock;
const waitTime = Math.max(biteTime, lureTime);
const cycleTime = tCast + waitTime + hookTime + pre;
```

#### B. 未発見即竿上げ (Rest if no disc)
設定が有効で、かつ「発見」に至らなかった場合、魚がかかるのを待たずに即座に竿を上げる。

$$T_{Cycle} = T_{Pre} + D_{Cast} + (n \times D_{Lure}) + D_{Rest}$$

* **特徴**:
    * ルアー後の空白時間 (`D_BLK`) を待たない。
    * 魚のバイト時間を待たない。
    * 必ず `D_REST` で終了する。
    * この場合、そのサイクルのヒット率は強制的に **0%** となる。

**実装コード (`isQuit` true時)**:
```javascript
// D_BLKを含まず、D_RESTを加算する
cycleTime = tCast + (p.n * tLureAction) + tRest + pre;
hitProb = 0;
```

#### C. 期待値 (Expected Time)
ターゲットを1匹入手するために必要な平均時間の期待値。

$$E[Time] = \frac{\sum (P_i \times T_{Cycle, i}) - (P_{Target} \times T_{Hook, Target})}{P_{Target}}$$

* **分子**: 1回釣り上げるのにかかる平均時間から、「ターゲット釣り上げ動作（成功時のコスト）」を引いたもの。これにより、純粋な「待ち時間」の期待値を算出する。
* **分母**: ターゲットのヒット率。

---

## 4. データ構造 (Data Structure)

### 4.1 マスターデータ構造 (JSON)
本システムがロードする `logic_master.json` のスキーマ定義。

```json
{
  "version": "2.8.0",
  "spots": {
    "釣り場名": {
      "expansion": "拡張名",
      "area": "エリア名",
      "weathers": ["晴れ", "雨"], // 利用可能な天気
      "baits": ["虫", "ルアー"], // 利用可能な餌
      "fish_list": ["魚A", "魚B"] // 生息する魚のリスト
    }
  },
  "weights": {
    "釣り場|天気|餌": [ // 複合キー
      { "fish": "魚名", "weight": 200, "bite_time": 10 }
    ]
  },
  "probabilities": [
    {
      "spot": "釣り場",
      "weather": "天気",
      "bait": "餌",
      "lure_type": "ルアー種別",
      "disc_rates": [20.5, 30.0, 45.0], // Step1~3の発見率
      "hidden_hit_rates": {
        "n1_d1_g0": 15.0, // n1(1回使用)のデータ
        "n2_d1_g2": 50.0  // n2(2回使用)のデータ
      }
    }
  ]
}
```

### 4.2 データ変換ロジック (CSV to JSON)
`data_converter.html` が行う処理の特記事項。

#### スポット情報の統合
マスタ-2（階層定義）とマスタ-3（詳細定義）を統合し、詳細データがないスポットについても空配列を持つオブジェクトとして初期化する。これにより、未定義スポット選択時のエラーハンドリングが可能となる。

**実装コード**:
```javascript
// 階層定義から全スポットを初期化
hierarchyData.forEach(row => {
    master.spots[row['釣り場']] = { ..., fish_list: [] };
});
// 詳細定義があれば追記
spotsData.forEach(row => { ... });
```

#### 隠し魚ヒット率のマッピング (ID変換)
CSVのカラム名を、システム内部で使用するシナリオIDへ変換する。
**注意**: 「ルアー1回使用」のデータは `n1`、「2回使用」は `n2` に正しくマッピングする必要がある。

**マッピング定義 (`hiddenHitMap`)**:
```javascript
const hiddenHitMap = {
    // 【重要】ヒット率1の列は n1_d1_g0 にマッピング
    '発見1型確1なし隠しヒット率1': 'n1_d1_g0', 
    
    // ヒット率2の列は n2...
    '発見1型確2あり隠しヒット率2': 'n2_d1_g2',
    '発見2型確2なし隠しヒット率2': 'n2_d2_g0', 
    // ...
};
```