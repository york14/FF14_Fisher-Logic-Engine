# 漁師論理エンジン (FLE) システム仕様書

**Version**: 3.1.0
**Last Updated**: 2026/01/13
**Target Logic**: FLE v2.5.4 / Data Converter v2.8

---

## 目次
1.  **ドメイン知識 (Domain Knowledge)**
    * 1.1 釣りの基本メカニクス
    * 1.2 魚の属性と分類 (Attributes)
    * 1.3 抽選の仕組み (Weight System)
    * 1.4 アクションと状態変化
    * 1.5 ルアーのメカニクスと隠し魚の出現論理
    * 1.6 システムの前提条件と制約 (Assumptions & Constraints)
2.  **システム要件 (System Requirements)**
    * 2.1 機能構成
    * 2.2 UI仕様と状態管理
    * 2.3 エラーハンドリング
3.  **ロジック仕様 (Logic Specification)**
    * 3.1 定数定義 (GDS)
    * 3.2 シナリオIDと状態定義
    * 3.3 確率・重み計算ロジック
    * 3.4 時間計算ロジック
4.  **データ構造 (Data Structure)**
    * 4.1 マスターデータ構造 (JSON)
    * 4.2 データ変換ロジック (CSV to JSON)

---

## 1. ドメイン知識 (Domain Knowledge)

本システムがシミュレートする対象である「FF14の釣り」に関する基本概念とルールを定義する。

### 1.1 釣りの基本メカニクス
釣りは「キャスティング（開始）」から「フッキング（釣り上げ）または竿上げ」までを1つの**サイクル**として扱う。

1.  **キャスティング (Casting)**: 釣りを開始する動作。
2.  **待機 (Wait)**: 魚がヒットするまでの時間。
3.  **アタリ (Bite)**: 魚がかかった合図。震動（演出）としてプレイヤーに伝わる。
4.  **フッキング (Hook)**: アタリに合わせて釣り上げる動作。成功すると魚を獲得し、サイクルが終了する。
5.  **竿上げ (Rest)**: 魚がかかる前、またはかかった後に、釣らずに竿を上げる動作。魚は獲得できず、サイクルが終了する。
    * ※本システムでは、この動作にかかる時間を `D_REST` として定義する。

### 1.2 魚の属性と分類 (Attributes)
各魚種は以下の固有属性を持つ。

* **型 (Jaws)**: ルアーへの反応やフッキングの種類を決定する属性。
    * **小型 (small jaws)**: モデストルアー対象。
    * **大型 (large jaws)**: アンビシャスルアー対象。
* **釣り上げ動作時間 (Hook Time)**: 魚を釣り上げる際に発生する物理的な拘束時間。魚種ごとに固有の値を持つ。
* **隠し魚 / 希少魚 (Hidden fish / Rare Species)**: 通常の状態では出現せず、ルアーアクションによる「誘引」が成功した場合のみ出現する特殊な魚種。

### 1.3 抽選の仕組み (Weight System)
魚の抽選は、各魚種に設定された**「重み (Weight)」**に基づく確率的抽選によって行われる。

* **基礎重み**: 釣り場・天気・餌の条件ごとに定義された初期値。
* **重み補正**: プレイヤーのアクション（ルアー使用など）によって、特定の魚種の重みが増減する。
* **抽選確率**:
    $$P(魚種A) = \frac{\text{魚種Aの現在重み}}{\text{全候補の現在重みの総和}}$$

### 1.4 アクションと状態変化
プレイヤーは以下のスキルを使用して抽選確率や時間を操作できる。

| アクション名 | ゲーム内名称 | 効果概要 |
| :--- | :--- | :--- |
| **撒き餌** | Chum | 魚がかかるまでの待機時間を短縮する。 |
| **トレードリリース** | Surface Slap | 特定の魚種を次回の抽選候補から除外する（重みを0にする）。 |
| **ルアー** | Ambitious/Modest Lure | 適合する型の魚の重みを増加させる。また、確率で「型確定」や「発見」が発生する。 |

### 1.5 ルアーのメカニクスと希少種の出現論理
ルアーアクション (Ambitious/Modest Lure) は、魚の重み補正に加え、以下の2つの独立した現象を確率的に発生させる。

1.  **型確定 (Guarantee)**
    * **定義**: 次にかかる魚の「型（大型/小型）」が、使用したルアーの対象型に固定される現象。
    * **発生条件**: ルアー使用時、発見の有無や隠し魚の存在に関わらず、一定確率で発生する。
    * **効果**: 確定した型と異なる魚種の重みが強制的に $0$ となる。

2.  **発見 (Discovery)**
    * **定義**: 隠れている魚の気配を感じ取った状態。
    * **発生条件**: 隠し魚が設定されている釣り場において、ルアー使用時に一定確率で発生する。
    * **効果**: **「隠し魚 (Hidden Fish)」** の出現フラグが立つ。

3.  **隠し魚の出現 (Hidden Fish Appearance)**
    * **定義**: 通常状態では重みが $0$ （出現しない）である特殊な魚種。
    * **出現条件**: 上記の **「発見」** 状態でのみ、固有のヒット率を持ち抽選テーブルに乗る。

### 1.6 システムの前提条件と制約 (Assumptions & Constraints)
本シミュレータにおける計算上の前提条件および実装されていない要素。

1.  **獲得率100%の前提**:
    * フッキングした魚は**必ず獲得できる（バラさない）**ものと仮定する。
    * フッキング失敗による時間ロスや再抽選は考慮しない。
2.  **Catch All (外道も全て釣る) モード**:
    * この設定がONの場合、ターゲット以外の魚（外道）がかかった際も「フッキング」を行うものとする。
    * 所要時間は「竿上げ時間 (`D_REST`)」ではなく、その魚固有の「釣り上げ動作時間 (`hook_time`)」が加算される。
3.  **GP (技力) 非考慮**:
    * 撒き餌やトレードリリースに必要なGPの消費・回復は計算に含まない。プレイヤーは常にスキルを使用可能な状態にあると仮定する。
4.  **単一ターゲット**:
    * 最適化の対象は「指定された1種類のターゲット魚」のみとし、複数の魚種を同時に狙う複合的な期待値計算は行わない。

---

## 2. システム要件 (System Requirements)

### 2.1 機能構成

#### A. 手動設定モード (Manual Mode)
特定の条件とスキル回数を指定し、その単一シナリオにおける詳細な確率と時間を計算するモード。

* **入力**: 釣り場、天気、餌、ターゲット、ルアー種類・回数、各ステップの結果(発見/型確/なし)。
* **出力**: ターゲットヒット率、サイクル時間、期待待機時間、全魚種の内訳テーブル。
* **実装関数**: `runManualMode(config)`

#### B. 戦略評価モード (Strategy Mode)
複数のシナリオ（発見した時点でルアー使用を停止など）を内包した「戦略プリセット」を選択し、戦略全体の平均的なパフォーマンスを評価・比較するモード。

* **入力**: 戦略セットA/Bそれぞれのプリセット（例：「L2固定」「発見延長優先」）、ルアー設定。
* **出力**: セットA/Bの期待値比較カード、シナリオ発生確率Top3、ヒット率Top3。
* **実装関数**: `runStrategyMode(config)`

### 2.2 UI仕様と状態管理

#### レイアウト
* **3ペイン構成**:
    * 左パネル: 設定（入力）
    * 中央パネル: 結果（出力）
    * 右パネル: 詳細デバッグ（折りたたみ可能）
* **リサイザー**: パネル間の境界線をドラッグして幅を調整可能。
    * 実装: `initResizers()`

#### 状態管理フロー
1.  **初期状態**: `OFFLINE`。JSON読み込み待ち。全コントロール無効化。
2.  **ロード後**: `ONLINE`。`masterDB` にデータ格納。`probabilityMap` 生成。コントロール有効化。
3.  **再計算トリガー**: 各種プルダウン/チェックボックスの `change` イベントで `updateSimulation()` を呼び出す。

### 2.3 エラーハンドリング

#### データ未定義エラー
ユーザーが選択した「釣り場」に対応する詳細データ（魚リスト等）がマスタに存在しない場合。

* **検知**: `masterDB.spots[spot].fish_list.length === 0`
* **挙動**:
    * 計算処理を中断 (`return`)。
    * 中央パネルに赤枠で「⚠️ データ未定義」を表示。
    * `updateSpotDependents()` 内で制御。

#### 不正な設定エラー
* **例**: ルアー設定で「発見」を2回以上選択した場合。
* **挙動**: 赤字で「発見は1度までです」と表示し、計算を中断。

---

## 3. ロジック仕様 (Logic Specification)

本システムの核心となる計算アルゴリズムおよび定数を定義する。

### 3.1 定数定義 (GDS)
時間の計算および重み補正に使用する標準定数（**GDS**: Game Duration Standards）。

| 定数名 | 値 | 単位 | 説明 |
| :--- | :--- | :--- | :--- |
| `D_CAST` | **0.0** | sec | キャスティング動作時間（サイクル計算除外）。 | |
| `D_LURE` | **2.5** | sec | ルアーアクション1回あたりにかかる動作時間。 |
| `D_BLK` | **2.5** | sec | ルアー使用後空白時間（魚がかからない空白時間）。 |
| `D_CHUM` | **1.0** | sec | 撒き餌使用にかかる動作時間。 |
| `D_REST` | **2.0** | sec | 竿上げにかかる動作時間。 |
| `C_CHUM` | **0.5** | - | 撒き餌使用時の待機時間短縮係数（乗算）。 | |
| `M_N1` | **1.5** | - | ルアー1回使用時の、適合する型の魚への重み倍率。 |
| `M_N2` | **2.0** | - | ルアー2回使用時の、適合する型の魚への重み倍率。 |
| `M_N3` | **6.0** | - | ルアー3回使用時の、適合する型の魚への重み倍率。 |

**実装コード (main.js)**:
```javascript
const GDS = {
    D_CAST: 0.0, D_LURE: 2.5, D_BLK: 2.5, D_CHUM: 1.0, D_REST: 2.0,
    C_CHUM: 0.5, M_N1: 1.5, M_N2: 2.0, M_N3: 6.0
};
```

### 3.2 シナリオIDと状態定義
ルアーの使用結果（シナリオ）は、以下のID形式で一意に管理する。

**フォーマット**: `n{回数}_d{発見ステップ}_g{型確定ステップ}`

* **n (Number)**: ルアーを使用した総回数 (0, 1, 2, 3)。
* **d (Discovery)**: 何回目のルアーで「発見」したか (0=なし, 1, 2, 3)。発見は最大1回まで。
* **g (Guarantee)**: 何回目のルアーで「型確定」したか (0=なし, 複数可 例:12, 23)。

**生成ロジック (`constructScenarioId` / `parseScenarioId`)**:
```javascript
// ID生成のイメージ
function constructScenarioId(count, steps) {
    let disc = 0;
    let guars = [];
    steps.forEach((action, i) => {
        if (action === 'disc' && disc === 0) disc = i + 1;
        if (action === 'guar') guars.push(i + 1);
    });
    const gStr = guars.length > 0 ? guars.join('') : '0';
    return `n${count}_d${disc}_g${gStr}`; // 例: n2_d1_g2
}
```

### 3.3 確率・重み計算ロジック

#### 3.3.1 シナリオ発生確率
各シナリオが発生する確率は、マスタデータ（`probabilities`）に定義された「各ステップごとの確率」を乗算して求める。

**計算フロー (`calculateScenarioStats` 内)**:
```javascript
let scenarioProb = 1.0;
// 各ステップ i (1～n) についてループ
for (let i = 1; i <= n; i++) {
    let stepProb = 0;
    if (!found) { // 未発見状態
        // disc_rates[i-1], guar_rates_nodisc[i-1] を使用
        if (action === 'disc') stepProb = pDisc;
        else if (action === 'guar') stepProb = (1.0 - pDisc) * pGuar;
        else stepProb = (1.0 - pDisc) * (1.0 - pGuar);
    } else { // 発見済み状態
        // guar_rates_after_disc を使用
        stepProb = (action === 'guar') ? pGuarAfter : (1.0 - pGuarAfter);
    }
    scenarioProb *= stepProb;
}
```

#### 3.3.2 魚種ごとのヒット率 ($P_{Hit}$)
シナリオ確定後の各魚種のヒット率は以下の手順で算出する。

1.  **隠し魚の判定**:
    * シナリオIDに対応する固定ヒット率をマスタから取得する ($P_{Hidden}$)。
    * 未発見シナリオの場合は 0% とする。

2.  **通常魚の重み計算**:
    * 各魚種 $i$ について、基礎重み $W_{base}$ に補正倍率 $M$ を掛ける。
    * $M$ の決定ルール:
        * トレードリリース対象魚: $M = 0$
        * ルアー使用かつ型が一致: $M = M_{N\text{x}}$ (回数に応じた倍率)
        * ルアー使用かつ型が不一致:
            * 直近で型確定している場合: $M = 0$
            * それ以外: $M = 1.0$
    * 最終重み $W_{final, i} = W_{base, i} \times M$

**境界条件の処理**:
* もし $W_{total} \le 0$ （全ての魚の重みが0）となった場合、通常魚のヒット率はすべて $0$ となる。

**実装コード (`calculateScenarioStats` 内)**:
```javascript
baseWeights.forEach(w => {
    let m = 1.0;
    if (w.fish === slapFish) { m = 0; }
    else if (lureActive) {
        if (typeMatch) m = modN; // M_N1, M_N2, M_N3
        else m = lastGuar ? 0 : 1.0;
    }
    weightDetails.push({ final: w.weight * m, /* ... */ });
});
```

3.  **確率分配**:
    * 通常魚の合計重み $W_{total} = \sum W_{final}$
    * 通常魚 $i$ のヒット率:
        $$P_i = \frac{W_{final, i}}{W_{total}} \times (1.0 - P_{Hidden})$$

### 3.4 時間計算ロジック

1サイクルにかかる時間は、プレイスタイル設定（特に「未発見即竿上げ」）によって計算式が異なる。

#### A. 通常サイクル（釣り上げ/竿上げ）
魚がかかるのを待ち、ヒット後に釣り上げる（または竿上げする）場合の所要時間。

$$T_{Cycle} = T_{Pre} + D_{Cast} + T_{Wait} + T_{Hook}$$

* **$T_{Pre}$**: 撒き餌使用時は `D_CHUM`、未使用時は 0。
* **$T_{Wait}$**: 以下の2つの値の**大きい方**を採用する。
    1.  **バイト時間**: 魚固有の基礎待機時間 $\times$ (`C_CHUM` or 1.0)。
    2.  **ルアー拘束時間**: $D_{Cast} + (n \times D_{Lure}) + D_{BLK}$
        * ※ルアー動作中は魚がかからないため、ルアー回数が多いほど最低待機時間は長くなる。
* **$T_{Hook}$**:
    * ターゲット魚またはCatchAll対象の場合: 魚固有の `hook_time`。
    * 外道の場合: 竿上げによる `D_REST`。

**実装コード**:
```javascript
const biteTime = isChum ? (baseBite * GDS.C_CHUM) : baseBite;
const lureTime = tCast + (n * tLureAction) + tLureBlock;
const waitTime = Math.max(biteTime, lureTime);
const cycleTime = tCast + waitTime + hookTime + pre;
```

#### B. 未発見即竿上げ (Rest if no disc)
設定が有効で、かつ「発見」に至らなかった場合、魚がかかるのを待たずに即座に竿を上げる。

$$T_{Cycle} = T_{Pre} + D_{Cast} + (n \times D_{Lure}) + D_{Rest}$$

* **特徴**:
    * ルアー後の空白時間 (`D_BLK`) を待たない。
    * 魚のバイト時間を待たない。
    * 必ず `D_REST` で終了する。
    * この場合、そのサイクルのヒット率は強制的に **0%** となる。

**実装コード (`isQuit` true時)**:
```javascript
// D_BLKを含まず、D_RESTを加算する
cycleTime = tCast + (p.n * tLureAction) + tRest + pre;
hitProb = 0;
```

#### C. 期待値 (Expected Time)
ターゲットを1匹入手するために必要な平均時間の期待値。

$$E[Time] = \frac{\sum (P_i \times T_{Cycle, i}) - (P_{Target} \times T_{Hook, Target})}{P_{Target}}$$

* **分子**: 1回釣り上げるのにかかる平均時間から、「ターゲット釣り上げ動作（成功時のコスト）」を引いたもの。これにより、純粋な「待ち時間」の期待値を算出する。
* **分母**: ターゲットのヒット率。

---

## 4. データ構造 (Data Structure)

### 4.1 マスターデータ構造 (JSON)
本システムがロードする `logic_master.json` のスキーマ定義。

**※注記**: CSVなどの入力ファイルでは確率は「% (0-100)」で表記されるが、本JSONおよび内部計算においては一部が「係数 (0.0-1.0)」として扱われる場合があるため、変換ロジックに依存する。

```json
{
  "version": "2.8.0",
  "spots": {
    "釣り場名": {
      "expansion": "拡張名",
      "area": "エリア名",
      "weathers": ["晴れ", "雨"], // 利用可能な天気
      "baits": ["虫", "ルアー"], // 利用可能な餌
      "fish_list": ["魚A", "魚B"] // 生息する魚のリスト
    }
  },
  "weights": {
    "釣り場|天気|餌": [ // 複合キー
      { "fish": "魚名", "weight": 200, "bite_time": 10 }
    ]
  },
  "probabilities": [
    {
      "spot": "釣り場",
      "weather": "天気",
      "bait": "餌",
      "lure_type": "ルアー種別",
      "slap_target": "トレード対象魚名", // ※システム内部キーは 'slap_target'
      "disc_rates": [20.5, 30.0, 45.0], // Step1~3の発見率
      "hidden_hit_rates": {
        "n1_d1_g0": 15.0, // n1(1回使用)のデータ
        "n2_d1_g2": 50.0  // n2(2回使用)のデータ
      }
    }
  ]
}
```

### 4.2 データ変換ロジック (CSV to JSON)
`data_converter.html` が行う処理の特記事項。

#### スポット情報の統合
マスタ-2（階層定義）とマスタ-3（詳細定義）を統合し、詳細データがないスポットについても空配列を持つオブジェクトとして初期化する。これにより、未定義スポット選択時のエラーハンドリングが可能となる。

**実装コード**:
```javascript
// 階層定義から全スポットを初期化
hierarchyData.forEach(row => {
    master.spots[row['釣り場']] = { ..., fish_list: [] };
});
// 詳細定義があれば追記
spotsData.forEach(row => { ... });
```

#### 隠し魚ヒット率のマッピング (ID変換)
CSVのカラム名を、システム内部で使用するシナリオIDへ変換する。
**注意**: 「ルアー1回使用」のデータは `n1`、「2回使用」は `n2` に正しくマッピングする必要がある。

**マッピング定義 (`hiddenHitMap`)**:
```javascript
const hiddenHitMap = {
    // 【重要】ヒット率1の列は n1_d1_g0 にマッピング
    '発見1型確1なし隠しヒット率1': 'n1_d1_g0', 
    
    // ヒット率2の列は n2...
    '発見1型確2あり隠しヒット率2': 'n2_d1_g2',
    '発見2型確2なし隠しヒット率2': 'n2_d2_g0', 
    // ...
};
```